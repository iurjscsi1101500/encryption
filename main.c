#include <stdio.h>
#include "encryption.h"

typedef struct {
    const char *name;
    const uint8_t key[32];
    const uint8_t nonce[12];
    const uint8_t *aad;
    size_t aad_len;
    const uint8_t *pt;
    size_t pt_len;
    const uint8_t *ct;  // includes tag
    size_t ct_len;
} test256_t;

/* — Vector C.2.1: Plaintext = 0, AAD = 0 — */
static const uint8_t key1[32] = {
    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
static const uint8_t nonce1[12] = {
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
static const uint8_t pt1[] = { };
static const uint8_t aad1[] = { };
static const uint8_t ct1[] = {
    0x07,0xf5,0xf4,0x16,0x9b,0xbf,0x55,0xa8,
    0x40,0x0c,0xd4,0x7e,0xa6,0xfd,0x40,0x0f
};

static const test256_t tests256[] = {
    { "256‑bit Test 1: Zero PT, Zero AAD",
      { /* key */ 
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
      },
      { 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
      aad1, 0,
      pt1, 0,
      ct1, sizeof(ct1)
    },
    { "256‑bit Test 2: 8‑byte PT, zero AAD",
      { /* same key */ 
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
      },
      { 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
      NULL, 0,
      (uint8_t[]){ 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, 8,
      (uint8_t[]){
        0xc2,0xef,0x32,0x8e,0x5c,0x71,0xc8,0x3b,
        0x84,0x31,0x22,0x13,0x0f,0x73,0x64,0xb7,
        0x61,0xe0,0xb9,0x74,0x27,0xe3,0xdf,0x28
      }, 24
    },
    { "256‑bit Test 3: 12 byte PT, zero AAD",
      { /* same key */ 
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
      },
      { 0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
      NULL, 0,
      (uint8_t[]){ 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                   0x00,0x00,0x00,0x00 }, 12,
      (uint8_t[]){
        0x9a,0xab,0x2a,0xeb,0x3f,0xaa,0x0a,0x34,
        0xae,0xa8,0xe2,0xb1,0x8c,0xa5,0x0d,0xa9,
        0xae,0x65,0x59,0xe4,0x8f,0xd1,0x0f,0x6e,
        0x5c,0x9c,0xa1,0x7e
      }, 28
    },
    { "256‑bit Test 4: 16 byte PT, zero AAD",
      { /* same key */ },
      { 0x03,0,0,0,0,0,0,0,0,0,0,0 },
      NULL, 0,
      (uint8_t[]){
        0x01,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00
      }, 16,
      (uint8_t[]){
        0x85,0xa0,0x1b,0x63,0x02,0x5b,0xa1,0x9b,
        0x7f,0xd3,0xdd,0xfc,0x03,0x3b,0x3e,0x76,
        0xc9,0xea,0xc6,0xfa,0x70,0x09,0x42,0x70,
        0x2e,0x90,0x86,0x23,0x83,0xc6,0xc3,0x66
      }, 32
    },
    { "256‑bit Test 5: 32 byte PT, zero AAD",
      { /* same key */ },
      { 0x03,0,0,0,0,0,0,0,0,0,0,0 },
      NULL, 0,
      (uint8_t[]){
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00
      }, 32,
      (uint8_t[]){
        0x4a,0x6a,0x9d,0xb4,0xc8,0xc6,0x54,0x92,
        0x01,0xb9,0xed,0xb5,0x30,0x06,0xcb,0xa8,
        0x21,0xec,0x9c,0xf8,0x50,0x94,0x8a,0x7c,
        0x86,0xc6,0x8a,0xc7,0x53,0x9d,0x02,0x7f,
        0xe8,0x19,0xe6,0x3a,0xbc,0xd0,0x20,0xb0,
        0x06,0xa9,0x76,0x39,0x76,0x32,0xeb,0x5d
      }, 48
    },
    { "256‑bit Test 6: 48 byte PT, zero AAD",
      { /* same key */ },
      { 0x03,0,0,0,0,0,0,0,0,0,0,0 },
      NULL, 0,
      (uint8_t[]){
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
      }, 48,
      (uint8_t[]){
        0xc0,0x0d,0x12,0x18,0x93,0xa9,0xfa,0x60,
        0x3f,0x48,0xcc,0xc1,0xca,0x3c,0x57,0xce,
        0x74,0x99,0x24,0x5e,0xa0,0x04,0x6d,0xb1,
        0x6c,0x53,0xc7,0xc6,0x6f,0xe7,0x17,0xe3,
        0x9c,0xf6,0xc7,0x48,0x83,0x7b,0x61,0xf6,
        0xee,0x3a,0xdc,0xee,0x17,0x53,0x4e,0xd5,
        0x79,0x0b,0xc9,0x68,0x80,0xa9,0x9b,0xa8,
        0x04,0xbd,0x12,0xc0,0xe6,0xa2,0x2c,0xc4
      }, 64
    },
    { "256‑bit Test 7: 64 byte PT, zero AAD",
      { /* same key */ },
      { 0x03,0,0,0,0,0,0,0,0,0,0,0 },
      NULL, 0,
      (uint8_t[]){
        0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00
      }, 64,
      (uint8_t[]){
        0xc2,0xd5,0x16,0x0a,0x1f,0x86,0x83,0x83,0x49,0x10,0xac,0xda,0xfc,0x41,0xfb,0xb1,
        0x63,0x2d,0x4a,0x35,0x3e,0x8b,0x90,0x5e,0xc9,0xa5,0x49,0x9a,0xc3,0x4f,0x96,0xc7,
        0xe1,0x04,0x9e,0xb0,0x80,0x88,0x38,0x91,0xa4,0xdb,0x8c,0xaa,0xa1,0xf9,0x9d,0xd0,
        0x04,0xd8,0x04,0x87,0x54,0x07,0x35,0x23,0x4e,0x37,0x44,0x51,0x2c,0x6f,0x90,0xce,
        0x11,0x28,0x64,0xc2,0x69,0xfc,0x0d,0x9d,0x88,0xc6,0x1f,0xa4,0x7e,0x39,0xaa,0x08
      }, 80
    },
    /* --- Counter wrap test from C.3 --- */
    { "256‑bit Counter Wrap Test 1",
      { 0x00 },  // key all zero
      { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
      NULL, 0,
      (uint8_t[]){
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x4d,0xb9,0x23,0xdc,0x79,0x3e,0xe6,0x49,
        0x7c,0x76,0xdc,0xc0,0x3a,0x98,0xe1,0x08,
        0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00
      }, 32,
      (uint8_t[]){
        0xf3,0xf8,0x0f,0x2c,0xf0,0xcb,0x2d,0xd9,
        0xc5,0x98,0x4f,0xcd,0xa9,0x08,0x45,0x6c,
        0xc5,0x37,0x70,0x3b,0x5b,0xa7,0x03,0x24,
        0xa6,0x79,0x3a,0x7b,0xf2,0x18,0xd3,0xea,
        0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
      }, 48
    },
    // (Add more counter-wrap tests if needed, like the second one)
};

static const size_t TEST256_COUNT = sizeof(tests256)/sizeof(tests256[0]);

/* ========== Helpers ========== */

void hexdump(const uint8_t *buf, size_t len) {
    for (size_t i = 0; i < len; i++) {
        printf("%02x", buf[i]);
        if (i + 1 < len) printf(" ");
    }
    printf("\n");
}

/* ========== RUN TESTS ========== */

int main(void) {
    uint8_t out[1024];
    size_t out_len;

    printf("Running %zu AES‑256‑GCM‑SIV tests\n", TEST256_COUNT);

    for (size_t ti = 0; ti < TEST256_COUNT; ti++) {
        const test256_t *t = &tests256[ti];
        printf("Test %zu: %s\n", ti + 1, t->name);

        out_len = 0;
        int err = encrypt_sym(
            t->key, t->nonce,
            t->pt, t->pt_len,
            t->aad, t->aad_len,
            out, &out_len
        );

        if (err) {
            printf("  ✗ encrypt_sym returned error %d\n", err);
            continue;
        }

        if (out_len != t->ct_len) {
            printf("  ✗ output length mismatch: expected %zu, got %zu\n",
                   t->ct_len, out_len);
            printf("  Expected CT+Tag: ");
            hexdump(t->ct, t->ct_len);
            printf("  Got           : ");
            hexdump(out, out_len);
            continue;
        }

        if (memcmp(out, t->ct, t->ct_len) != 0) {
            printf("  ✗ ciphertext+tag mismatch\n");
            printf("  Expected: ");
            hexdump(t->ct, t->ct_len);
            printf("  Got     : ");
            hexdump(out, out_len);
        } else {
            printf("  ✓ PASS\n");
        }

        printf("\n");
    }

    /* ========== Simple fuzz test ========== */
    printf("Running simple fuzz test...\n");
    const uint_fast8_t fuzz_key[32] = { 0x55 };
    const uint_fast8_t fuzz_nonce[12] = { 0x99 };
    uint8_t fuzz_pt[64];
    uint8_t fuzz_aad[32];
    for (int i = 0; i < 64; i++) fuzz_pt[i] = (uint8_t)rand();
    for (int i = 0; i < 32; i++) fuzz_aad[i] = (uint8_t)rand();

    out_len = 0;
    int err2 = encrypt_sym(
        fuzz_key, fuzz_nonce,
        fuzz_pt, sizeof(fuzz_pt),
        fuzz_aad, sizeof(fuzz_aad),
        out, &out_len
    );
    if (err2) {
        printf("Fuzz encrypt error: %d\n", err2);
    } else {
        printf("Fuzz encrypt succeeded, out_len = %zu\n", out_len);
    }

    return 0;
}
